'''
	文件内容
	1. 写入文件内容
	2. 写入文件序列
	3. 读取文件内容
	4. 读取一行内容
	5. 读取内容到列表
	6. 截取内容
	7. 刷新文件缓冲
	8. 浅谈with
'''

# 1. 写入文件到内容
#  	io对象.write('内容')
#  	
#  	返回值: 写入内容的长度
#  	注意: 
#  		会清除原有的内容, 再写入新的内容

a = open('a2.txt', 'w+')

b = a.write('how are you')
print(b)

a.seek(0)
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')




# 2. 写入文件序列
# 	io对象.writelines( 容器 )
# 	返回值: 无
li = ('床前明月光\n', '地上鞋两双\n', '床上狗男女\n','其中就有你\n')
li = {'床前明月光\n', '地上鞋两双\n', '床上狗男女\n','其中就有你\n'}
li = {'床前明月光\n':'地上鞋两双\n', '床上狗男女\n':'其中就有你\n'}
li = ['床前明月光\n', '地上鞋两双\n', '床上狗男女\n','其中就有你\n']
b = a.writelines(li)
a.close()
print(b)
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')


# 3. 读取内容
# 	io对象.read( n )
# 	参数:
# 		n 如果不填, 默认从当前指针开始, 读取到末尾
# 		n = 1, 从当前指针开始, 向后读取1位
# 		n = 2, 从当前指针开始, 向后读取2位
# 		...
# 		
# 	返回值: 读取的内容
a = open('a3.txt', 'r')
b = a.read()
print(b)
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')


# 4. 读取一行内容
# 	io对象.readline(n)
# 	
# 	参数:
# 		n 如果不填, 从当前指针开始, 向后读取一行 (不会到下一行)
# 		n = 1, 从当前指针开始, 向后读取1位
# 		n = 2, 从当前指针开始, 向后读取2位
# 		
# 		如果当前行 没有读取完毕, 下一次的readline会接着上一次继续读
# 		如果指定n时, 已经超过当前行, 那么不会读取下一行的内容, 只会读取当前一行
# 	
# 	返回值: 一行内容
# 
a = open('a2.txt', 'r')
# 不指定n时
b = a.readline()
print(b)

b = a.readline()
print(b)

b = a.readline()
print(b)

b = a.readline()
print(b)

a.seek(0)
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')

# 指定n时
b = a.readline(2)
print(b)

b = a.readline()
print(b)

b = a.readline(200)
print(b)

b = a.readline()
print(b)


# 5. 读取所有内容到 列表中
# 	io对象.readlines()
# 	
# 	每一行分配一个索引, 存入列表中
# 	第一行为索引0
# 	第二行为索引1
# 	...
a = open('a3.txt', 'r')
b = a.readlines()
print(b)
print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')



# 6. 截取文件内容
# 	io对象.truncate( n )
# 	
# 	功能: 从开头向后截取n 个字节, 剩余没有被截取的将全部删除
# 	返回值: 返回截取的长度
# 	
a = open('a3.txt', 'a')
b = a.truncate(2)
print(b)



# 7. 刷新文件缓冲
# 	io对象.flush()
# 	功能: 立马将缓冲区的内容存入文件中
# 	返回值: 无
# 	
# 	平时文件的写操作, 其他不会立马把内容写入文件, 只是把内容存入缓冲区
# 	当满足以下任意条件时, 即可将缓冲区内容存入文件中
# 		* 当整个程序自然结束时
# 		* 当运行到flush时
# 		* 当文件关闭时
# 		* 当缓冲区填满了, 将内容存入文件中, 再刷新刷新缓冲
#  
#  	利用pycharm, 通过断点调试来查看


# 8. 浅谈with
#  	在以上的操作, 经常忘记close操作, 导致内存在不断的浪费.
#  	with 会在文件操作完之后, 自动帮你关闭文件

a = open('a4.txt', 'r')
print( a.read() )
# 上面的a 没有关闭文件


with open('a4.txt','r') as file:
	print(file.read())
	pass

# 上面的file 已经帮你关闭的文件
# 在整个with的过程中, 没有close, 但是, with的代码块全部执行完时, 自动执行file.close()操作








